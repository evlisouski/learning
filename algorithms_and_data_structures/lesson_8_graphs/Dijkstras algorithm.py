# Матрица смежности
g = [
    [0, 0, 1, 1, 9, 0, 0, 0],
    [0, 0, 9, 4, 0, 0, 5, 0],
    [0, 9, 0, 0, 3, 0, 6, 0],
    [0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 5, 0],
    [0, 0, 7, 0, 8, 1, 0, 0],
    [0, 0, 0, 0, 0, 1, 2, 0],
]


def dijkstra(graph, start):
    lenght = len(graph)
    is_visited = [False] * lenght  # для хранения логических данных "посещали вершину или нет"
    cost = [float('inf')] * lenght  # изначально путь к конкретной вершине, изначально равен бесконечности
    parent = [-1] * lenght  # родитель вершины. Изначально храниться -1. В процессе записывается номер вершины

    cost[start] = 0  # стоимоть пути до начальной вершины равна нулю, т.к. мы находимся в ней изначально
    min_cost = 0  # показывает двигаемся дальше по графу или уже нет

    while min_cost < float("inf"):  # пока минимальная стоимость меньше бесконечности - обходим граф в цикле
        is_visited[start] = True  # начальная точка, ппомечена изначально как посещенная

        # проходим в цикле по той строке матрицы смежности где храниться значение start
        for i, vertex in enumerate(graph[start]):
            if vertex != 0 and not is_visited[i]:  # если начали с нулевой вершины, то по нулевой строке

                # если растояние до i вершины окажется больше чем сумма расмтояний
                # от вершины start до вершины i плюс значение которое уже храниться в вершине start
                if cost[i] > vertex + cost[start]:
                    cost[i] = vertex + cost[start]  # записываем более коротное растояние для i той вершины
                    parent[i] = start  # указываем какая вершина является родительской

        min_cost = float('inf')  # изменяем значение минимального пути на бесконечность
        for i in range(lenght):  # цикл, который пройдет по всем вершинам графа

            # если минималоьная стоимость окажется меньше чем очередная стоимость до вершины и эту вершину мы еще не посещали
            if min_cost > cost[i] and not is_visited[i]:
                min_cost = cost[i]  # то изменяем значение минимальной стоимости, сохраняем значение их текущей вершины
                start = i  # и запоминаем что теперь эта вершина является стартовой
    return cost


s = int(input('От какой вершины идти?: '))

print(dijkstra(g, s))  # Кратчайшие пути из начальой точки до каждой вершины
