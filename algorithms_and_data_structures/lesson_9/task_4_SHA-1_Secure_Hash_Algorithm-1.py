# SHA-1 Secure_Hash_Algorithm-1
# Получает на вход сообщение максимальной длины 2^64 бит и создает в качестве выхода хэш-строку длиной 160 бит
"ЭТО ПСЕВДОКОТ В PYTHON СТИЛЕ ДЛЯ ПОНИМАНИЯ АЛГОРИТМА !!! ОН НЕ ЗАПУСКАЕТСЯ"


def sha1(data):
    # переменные, хранящие 32 бита информации
    h0 = 0x67452301
    h1 = 0xEFCDAB89
    h2 = 0x98BADCFE
    h3 = 0x10325476
    h4 = 0xC3D2E1F0

    # в строку len помещаем последовательность из 64 бит
    lenght = len(data)

    # сдвигаем значение data на один бит влево и добавляем туда единиуц
    # по сути дописываем 1 единичный бит в самом конке
    data = data << 1 + 1

    # если отсаток от деления длины data на 512 больше 448, то нужно заполнить нулями остав. часть
    if len(data) % 512 > 448:
        data = data << 64

    # добавляем пустые биты в конец строки чтобы остаток от деления равнялся 448
    data = data << (448 - len(data) % 512)

    # сдвигаем значение data еще на 64 бита влево и помещаем в эти 64 бита значение len
    data = data << 64 + lenght
    # после всего этого в переменной data храниться строка которую ввел пользователь,
    # некоторое количество нулей и в самом конце длина исходной строки, при этом
    # длина переменной data в битах будет макисмум делиться на 512

    # Цикл, который производит хэширвоание
    # на кажной итерации в переменную part_512 извлекаем 512 бит из переменной data
    for part_512 in data:
        w = []

        for i in range(16):
            # в очередной элемент w[i] помещаем очередной массив размером 32 бита из переменной part_512
            w[i] = part_512[:32]
            # сокращаем строку на 32 бита
            part_512 = part_512[32:]

            # массив w дополняем до 80 слов на 32 бита
        for i in range(16, 80):
            # определение очередного элемента, затем сдвина на 1 бит
            w[i] = (w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]) << 1

        a = h0
        b = h1
        c = h2
        d = h3
        e = h4

        # основной цикл на 80 итераций, именно в этом цикле происходит хэширование
        for i in range(80):
            if <= i <= 19:
                f = (b & c) | ((~b) & d)
                k = 0x5A827999

            elif 20 <= i <= 39:
                f = b ^ c ^ d
                k = 0x6ED9EBA1

            elif 40 <= i <= 59:
                f = (b & c) | (b & d) | (c & d)
                k = 0x8F1BBCDC

            elif 60 <= i <= 79:
                f = b ^ c ^ d
                k = 0xCA62C1D6

            temp = (a << 5) + f + e + k + w[i]
            e = d
            d = c
            c = b << 30
            b = a
            a = temp

        h0 = h0 + a
        h1 = h1 + b
        h2 = h2 + c
        h3 = h4 + d
        h4 = h4 + e

    # конкатенация
    hash = h0 + h1 + h2 + h3 + h4
    return hash
